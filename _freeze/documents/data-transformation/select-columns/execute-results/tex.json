{
  "hash": "00543ddff5331c7b2d22a6b8806d4f13",
  "result": {
    "markdown": "---\ntitle: Select columns\nexecute: \n  warning: false\n  output: false\neditor_options: \n  chunk_output_type: console\n---\n\n::: {.cell}\n\n:::\n\n\n\nThis chapter introduces tools to remove unnecessary columns from the data set. Or, positively stated, we learn how to specify the columns we need for our analysis. As with most data transformation operations, we mostly introduce functions from the `{dplyr}` package.\n\n## The `select` command\n\nThe function `select()` is the designated tool to select columns with `{dplyr}`. By passing different things to the function, we can efficiently define the set of columns in the resulting data frame.\n\n## By column names\n\nThe easiest and intuitive way to specify the columns we want is by listing their names. We can pass one or more column names to the `select()` function. In case of two or more, we use commas to separate the names:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Just one column name\norders %>% \n  select(order_id)\n\n#> # A tibble: 2,874 x 1\n#>        order_id\n#>           <dbl>\n#> 1 1130007101519\n#> 2 1130014965839\n#> 3 1130026958927\n#> ...\n\n# A list of column names\norders %>% \n  select(order_id, total_price)\n\n#> # A tibble: 2,874 x 2\n#>        order_id total_price\n#>           <dbl>       <dbl>\n#> 1 1130007101519        94.7\n#> 2 1130014965839        32.2\n#> 3 1130026958927        30.2\n#> ...\n```\n:::\n\n\n\nWhen we only want a few columns, this approach works fine and is usually a good choice. I expect you apply this method in more than 90% of all cases. However, there are cases when you'd wish there was something more flexible. Luckily, there is.\n\n## By name patterns\n\n### Names starting with a string\n\nSometimes we want to select columns based on a pattern of their names. Take the orders data set as an example. Here, all variables that contain information about the shipping address have the prefix `shipping`. We leverage this with the helper function `starts_with()`:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\norders %>% \n  select(starts_with(\"shipping\")) %>% \n  colnames()\n\n#> [1] \"shipping_address_city\"      \"shipping_address_zip\"       \"shipping_address_country\"  \n#> [4] \"shipping_address_latitude\"  \"shipping_address_longitude\"\n```\n:::\n\n\n\n### Names ending with a string\n\n### Names with a string anywhere\n\n### Using regular expressions\n\n## By data type\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\norders %>% \n  select(where(is.numeric))\n\norders %>% \n  select(where(is.logical))\n\norders %>% \n  select(where(is.character))\n\norders %>% \n  select(where(is.factor))\n\norders %>% \n  select(where(is.list))\n\n# The package lubridate provides a function to check for date (without time)\norders %>% \n  select(where(lubridate::is.Date))\n\n# Select all date/time columns\norders %>% \n  select(where(lubridate::is.POSIXct))\n```\n:::\n",
    "supporting": [
      "select-columns_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {
      "knitr": [
        "{\"type\":\"list\",\"attributes\":{},\"value\":[]}"
      ]
    },
    "preserve": null,
    "postProcess": false
  }
}