{
  "hash": "95783434483adc6a317c8b49f35bda06",
  "result": {
    "markdown": "---\ntitle: Select columns\nexecute: \n  warning: false\neditor_options: \n  chunk_output_type: console\n---\n\n::: {.cell}\n\n:::\n\n\n# Select columns \n\nThis chapter introduces tools to remove unnecessary columns from the data set. Or, if stated in a positive manner, we learn how to specify the columns we need for our analysis. As with most data transformation operations, we mostly introduce functions from the `{dplyr}` package.\n\n## The `select` command\n\nThe function `select()` is the designated tool to select columns with `{dplyr}`. By passing different things to the function, we can efficiently define the set of columns in the resulting data frame.\n\n## By column names\n\nThe easiest and intuitive way to specify the columns we want is by listing their names. We can pass one or more column names to the `select()` function. In case of two or more, we use commas to separate the names:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Just one column name\norders %>% \n  select(order_id)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 2,874 x 1\n        order_id\n           <dbl>\n 1 1130007101519\n 2 1130014965839\n 3 1130026958927\n 4 1130030563407\n 5 1130038853711\n 6 1130045964367\n 7 1130050519119\n 8 1130060283983\n 9 1130102194255\n10 1130106880079\n# ... with 2,864 more rows\n```\n:::\n\n```{.r .cell-code}\n#> # A tibble: 2,874 x 1\n#>        order_id\n#>           <dbl>\n#> 1 1130007101519\n#> 2 1130014965839\n#> 3 1130026958927\n#> ...\n\n# A list of column names\norders %>% \n  select(order_id, total_price)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 2,874 x 2\n        order_id total_price\n           <dbl>       <dbl>\n 1 1130007101519        94.7\n 2 1130014965839        32.2\n 3 1130026958927        30.2\n 4 1130030563407        32.2\n 5 1130038853711        30.2\n 6 1130045964367        30.2\n 7 1130050519119        30.2\n 8 1130060283983        32.2\n 9 1130102194255        96.7\n10 1130106880079        32.2\n# ... with 2,864 more rows\n```\n:::\n\n```{.r .cell-code}\n#> # A tibble: 2,874 x 2\n#>        order_id total_price\n#>           <dbl>       <dbl>\n#> 1 1130007101519        94.7\n#> 2 1130014965839        32.2\n#> 3 1130026958927        30.2\n#> ...\n```\n:::\n\n\nWhen we only want a few columns, this approach works fine and is usually a good choice. I expect you apply this method in more than 90% of all cases. However, there are cases when you'd wish there was something more flexible. Luckily, there is.\n\n## By name patterns\n\n### Names starting with a string\n\nSometimes we want to select columns based on a pattern of their names. Take the orders data set as an example. Here, all variables that contain information about the shipping address have the prefix `shipping`. We leverage this with the helper function `starts_with()`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\norders %>% \n  select(starts_with(\"shipping\")) %>% \n  colnames()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"shipping_address_city\"      \"shipping_address_zip\"      \n[3] \"shipping_address_country\"   \"shipping_address_latitude\" \n[5] \"shipping_address_longitude\"\n```\n:::\n\n```{.r .cell-code}\n#> [1] \"shipping_address_city\"      \"shipping_address_zip\"       \"shipping_address_country\"  \n#> [4] \"shipping_address_latitude\"  \"shipping_address_longitude\"\n```\n:::\n\n\n### Names ending with a string\n\n### Names with a string anywhere\n\n### Using regular expressions\n\n## By data type\n\n\n::: {.cell}\n\n```{.r .cell-code}\norders %>% \n  select(where(is.numeric))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 2,874 x 30\n        order_id order_~1 app_id curre~2 curre~3 curre~4 curre~5 total~6 total~7\n           <dbl>    <dbl>  <dbl>   <dbl>   <dbl>   <dbl>   <dbl>   <dbl>   <dbl>\n 1 1130007101519     1014 580111    94.7    94.7       2       0       2    96.7\n 2 1130014965839     1015 580111    32.2    32.2       0       0       0    32.2\n 3 1130026958927     1016 580111    30.2    30.2       2       0       2    32.2\n 4 1130030563407     1017 580111    32.2    32.2       0       0       0    32.2\n 5 1130038853711     1018 580111    30.2    30.2       2       0       2    32.2\n 6 1130045964367     1019 580111    30.2    30.2       2       0       2    32.2\n 7 1130050519119     1020 580111    30.2    30.2       2       0       2    32.2\n 8 1130060283983     1021 580111    32.2    32.2       0       0       0    32.2\n 9 1130102194255     1022 580111    96.7    96.7       0       0       0    96.7\n10 1130106880079     1023 580111    32.2    32.2       0       0       0    32.2\n# ... with 2,864 more rows, 21 more variables: total_outstanding <dbl>,\n#   total_price <dbl>, total_tax <dbl>, total_tip_received <dbl>,\n#   location_id <dbl>, customer_id <dbl>, customer_accepts_marketing <dbl>,\n#   customer_is_hsos <dbl>, customer_orders_count <dbl>,\n#   customer_total_spent <dbl>, customer_last_order_id <dbl>,\n#   customer_verified_email <dbl>, customer_tax_exempt <dbl>,\n#   shipping_address_zip <dbl>, shipping_address_latitude <dbl>, ...\n```\n:::\n\n```{.r .cell-code}\norders %>% \n  select(where(is.logical))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 2,874 x 3\n   test  taxes_included customer_sms_marketing_consent\n   <lgl> <lgl>          <lgl>                         \n 1 FALSE TRUE           NA                            \n 2 FALSE TRUE           NA                            \n 3 FALSE TRUE           NA                            \n 4 FALSE TRUE           NA                            \n 5 FALSE TRUE           NA                            \n 6 FALSE TRUE           NA                            \n 7 FALSE TRUE           NA                            \n 8 FALSE TRUE           NA                            \n 9 FALSE TRUE           NA                            \n10 FALSE TRUE           NA                            \n# ... with 2,864 more rows\n```\n:::\n\n```{.r .cell-code}\norders %>% \n  select(where(is.character))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 2,874 x 27\n   name  discount_~1 finan~2 fulfi~3 sourc~4 landi~5 landi~6 note  tags  proce~7\n   <chr> <chr>       <chr>   <chr>   <chr>   <chr>   <chr>   <chr> <chr> <chr>  \n 1 B1014 DCBPXGJB1J~ paid    fulfil~ web     /passw~ <NA>    <NA>  <NA>  direct \n 2 B1015 <NA>        paid    fulfil~ web     /walle~ <NA>    <NA>  <NA>  express\n 3 B1016 KY0D5MNEZB~ paid    fulfil~ web     /       <NA>    <NA>  <NA>  express\n 4 B1017 <NA>        paid    fulfil~ web     /walle~ <NA>    <NA>  <NA>  express\n 5 B1018 DCBPXGJB1J~ paid    fulfil~ web     <NA>    <NA>    <NA>  <NA>  express\n 6 B1019 DCBPXGJB1J~ paid    fulfil~ web     <NA>    <NA>    <NA>  <NA>  express\n 7 B1020 DCBPXGJB1J~ paid    fulfil~ web     <NA>    <NA>    <NA>  <NA>  express\n 8 B1021 <NA>        paid    fulfil~ web     /       <NA>    <NA>  <NA>  express\n 9 B1022 <NA>        paid    fulfil~ web     /walle~ <NA>    <NA>  <NA>  express\n10 B1023 <NA>        paid    fulfil~ web     <NA>    <NA>    <NA>  <NA>  express\n# ... with 2,864 more rows, 17 more variables: payment_details_gateway <chr>,\n#   payment_details_credit_card_company <chr>,\n#   customer_marketing_opt_in_level <chr>, customer_gender <chr>,\n#   customer_state <chr>, customer_note <chr>, customer_tags <chr>,\n#   customer_last_order_name <chr>, campaign_tag <chr>,\n#   shipping_address_city <chr>, shipping_address_country <chr>,\n#   billing_address_city <chr>, billing_address_country <chr>, ...\n```\n:::\n\n```{.r .cell-code}\norders %>% \n  select(where(is.factor))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 2,874 x 0\n```\n:::\n\n```{.r .cell-code}\norders %>% \n  select(where(is.list))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 2,874 x 0\n```\n:::\n\n```{.r .cell-code}\n# The package lubridate provides a function to check for date (without time)\norders %>% \n  select(where(lubridate::is.Date))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 2,874 x 0\n```\n:::\n\n```{.r .cell-code}\n# Select all date/time columns\norders %>% \n  select(where(lubridate::is.POSIXct))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 2,874 x 8\n   created_at          updated_at          processed_at       \n   <dttm>              <dttm>              <dttm>             \n 1 2019-05-24 12:59:16 2019-06-19 13:23:26 2019-05-24 12:59:15\n 2 2019-05-24 13:09:08 2019-06-21 14:40:07 2019-05-24 13:09:07\n 3 2019-05-24 13:22:41 2019-06-21 12:35:23 2019-05-24 13:22:40\n 4 2019-05-24 13:27:43 2019-06-21 14:27:18 2019-05-24 13:27:42\n 5 2019-05-24 13:36:46 2019-06-21 12:11:57 2019-05-24 13:36:45\n 6 2019-05-24 13:44:41 2019-06-21 14:37:21 2019-05-24 13:44:41\n 7 2019-05-24 13:49:21 2019-06-21 12:25:16 2019-05-24 13:49:20\n 8 2019-05-24 13:59:57 2019-06-21 11:49:47 2019-05-24 13:59:57\n 9 2019-05-24 14:43:53 2019-06-19 14:12:38 2019-05-24 14:43:53\n10 2019-05-24 14:48:16 2019-06-21 15:54:24 2019-05-24 14:48:16\n# ... with 2,864 more rows, and 5 more variables:\n#   customer_accepts_marketing_updated_at <dttm>, customer_created_at <dttm>,\n#   customer_updated_at <dttm>, cancelled_at <dttm>, closed_at <dttm>\n```\n:::\n:::\n",
    "supporting": [
      "select-columns_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}